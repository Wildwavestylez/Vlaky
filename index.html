<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8" />
<title>Transport Tycoon ‚Äì IndexedDB (CZ/DE/AT)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
html,body{height:100%;margin:0}
#map{height:100%}
#hamburger{position:fixed;top:10px;left:10px;z-index:1100;background:#111;color:#fff;border:0;border-radius:12px;padding:10px 12px;font-size:18px;box-shadow:0 4px 12px rgba(0,0,0,.2);cursor:pointer}
#menu{position:fixed;top:0;left:0;height:100%;width:340px;z-index:1000;background:#fff;box-shadow:2px 0 16px rgba(0,0,0,.15);transform:translateX(-360px);transition:transform .25s ease;padding:12px;overflow-y:auto}
#menu.open{transform:translateX(0)}
.offer{border:1px solid #e5e7eb;border-radius:10px;padding:10px;margin:8px 0}
.btn{display:inline-block;background:#0ea5e9;color:#fff;border:0;border-radius:8px;padding:8px 10px;font-weight:700;cursor:pointer}
.btn:disabled{opacity:.6;cursor:not-allowed}
.muted{color:#64748b}
.pill{display:inline-block;background:#f1f5f9;color:#0f172a;border-radius:999px;padding:2px 8px;font-size:12px}
#finance{
  position:fixed;
  top:10px;
  right:10px;
  z-index:1100;
  background:#fff;
  border-radius:10px;
  padding:8px 12px;
  box-shadow:0 4px 12px rgba(0,0,0,.2);
  font-weight:700;
}
#status{position:fixed;bottom:10px;right:10px;z-index:1100;background:#fff;border-radius:10px;padding:8px 12px;box-shadow:0 4px 12px rgba(0,0,0,.2);font-size:12px}
@media (max-width:480px){#menu{width:86vw;transform:translateX(-88vw)}}
</style>
</head>
<body>
<div id="map"></div>
<button id="hamburger">‚ò∞</button>
<aside id="menu">
  <h2 style="margin:6px 0 8px">Transport Tycoon (offline-ready)</h2>
  <div class="muted" style="font-size:12px;margin-bottom:6px">
    Data se stahuj√≠ po ~50√ó50 km dla≈ædic√≠ch do IndexedDB. Ka≈æd√Ωch 10 s dostane≈° n√°hodnou linku z DB. Po koupi se u≈æ nenab√≠z√≠.
  </div>
  <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px; flex-wrap:wrap">
    <span class="pill" id="poolCount">0 v DB</span>
    <span class="pill" id="offeredCount">0 v nab√≠dce</span>
    <span class="pill" id="ownedCount">0 koupeno</span>
    <span class="pill" id="tilesCount">0/0 dla≈ædic</span>
    <span class="pill" id="onlineBadge">stav: ?</span>
  </div>
  <div id="offers"></div>
</aside>
<div id="finance">üí∞ Pen√≠ze: <span id="money">2000</span> Kƒç</div>
<div id="status">‚åõ inicializuji‚Ä¶</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/* ===================== MAPA ===================== */
const map = L.map('map', { worldCopyJump:true }).setView([49.0, 13.3], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'¬© OpenStreetMap' }).addTo(map);
document.getElementById('hamburger').onclick = () => document.getElementById('menu').classList.toggle('open');

const BUS_ICON = L.icon({ iconUrl:"https://cdn-icons-png.flaticon.com/512/61/61212.png", iconSize:[24,24] });
const TRAM_ICON= L.icon({ iconUrl:"https://cdn-icons-png.flaticon.com/512/2847/2847720.png", iconSize:[24,24] });
const TRAIN_ICON=L.icon({ iconUrl:"https://cdn-icons-png.flaticon.com/512/854/854894.png", iconSize:[24,24] });
const PLANE_ICON=L.icon({ iconUrl:"https://cdn-icons-png.flaticon.com/512/34/34627.png", iconSize:[24,24] });

/* ===================== UI STATE ===================== */
let money = 2000;
const moneyEl = document.getElementById('money');
const offersEl = document.getElementById('offers');
const poolCountEl = document.getElementById('poolCount');
const offeredCountEl = document.getElementById('offeredCount');
const ownedCountEl = document.getElementById('ownedCount');
const tilesCountEl = document.getElementById('tilesCount');
const statusEl = document.getElementById('status');
const onlineBadge = document.getElementById('onlineBadge');

function setMoney(v){ money=v; moneyEl.textContent = money; }
function setStatus(txt){ statusEl.textContent = txt; }
function setOnlineBadge(){ onlineBadge.textContent = navigator.onLine ? 'online' : 'offline'; }
window.addEventListener('online', setOnlineBadge);
window.addEventListener('offline', setOnlineBadge);
setOnlineBadge();

/* ===================== INDEXEDDB ===================== */
const DB_NAME = 'TransportDB';
const DB_VERSION = 2;
let db;

function openDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      const lines = db.createObjectStore('lines', { keyPath: 'id' });
      lines.createIndex('type', 'type', { unique:false });
      lines.createIndex('owned', 'owned', { unique:false });
      lines.createIndex('bboxKey', 'bboxKey', { unique:false });
      const meta = db.createObjectStore('meta', { keyPath: 'key' });
      db.createObjectStore('owned', { keyPath: 'id' });
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}

async function putLines(lines){
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(['lines'], 'readwrite');
    const store = tx.objectStore('lines');
    lines.forEach(l=>{
      // fallback kl√≠ƒç
      const key = l.id || crypto.randomUUID();
      store.put({...l, id:key, owned:l.owned===true});
    });
    tx.oncomplete = ()=> resolve();
    tx.onerror = ()=> reject(tx.error);
  });
}

function markOwned(id){
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(['lines','owned'], 'readwrite');
    const s = tx.objectStore('lines');
    const o = tx.objectStore('owned');
    const getReq = s.get(id);
    getReq.onsuccess = ()=>{
      const rec = getReq.result;
      if(rec){
        rec.owned = true;
        s.put(rec);
        o.put({id});
      }
    };
    tx.oncomplete = ()=> resolve();
    tx.onerror = ()=> reject(tx.error);
  });
}

function countStore(storeName, indexName, query){
  return new Promise((resolve,reject)=>{
    const tx = db.transaction([storeName], 'readonly');
    const store = tx.objectStore(storeName);
    const source = indexName ? store.index(indexName) : store;
    const req = source.count(query || null);
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}

/* ===================== NAB√çZEN√ç LINEK (z DB) ===================== */
let ownedInSession = new Set(); // jen pro aktu√°ln√≠ hru

function updateBadges(){
  offeredCountEl.textContent = `${OFFERING.size} v nab√≠dce`;
  ownedCountEl.textContent = `${ownedInSession.size} koupeno`;

  // poƒçet v≈°ech linek v IndexedDB (ignorujeme owned)
  countStore('lines').then(c=>{
    poolCountEl.textContent = `${c} v DB`;
  }).catch(()=>{});
}

// kdy≈æ hr√°ƒç koup√≠ linku:
function buyLine(line){
  if(!line) return;
  ownedInSession.add(line.id);   // jen pro session
  OFFERING.delete(line.id);      // zmiz√≠ z aktu√°ln√≠ nab√≠dky
  updateBadges();
}

// naƒçten√≠ linek z IndexedDB do nab√≠dky
function refreshOfferings(){
  OFFERING.clear();
  dbGetAll('lines').then(lines=>{
    for(const line of lines){
      if(!ownedInSession.has(line.id)){ // filtrovat jen bƒõhem session
        OFFERING.set(line.id, line);
      }
    }
    updateBadges();
  });
}

/* ===================== PERSISTENCE STA≈ΩEN√ùCH DLA≈ΩDIC ===================== */
async function loadTilesDone(){
  const tx = db.transaction(['meta'], 'readonly');
  const store = tx.objectStore('meta');
  return new Promise((resolve,reject)=>{
    const req = store.get('tilesDone');
    req.onsuccess = ()=>{
      if(req.result && Array.isArray(req.result.value)){
        req.result.value.forEach(k=>tilesDone.add(k));
      }
      resolve();
    };
    req.onerror = ()=>resolve(); // ignorovat chybu
  });
}

async function saveTilesDone(){
  const tx = db.transaction(['meta'], 'readwrite');
  const store = tx.objectStore('meta');
  await store.put({ key:'tilesDone', value:[...tilesDone] });
}

const OFFERING = new Set();

async function getRandomOfferableLine(maxScan=infinity){
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(['lines'],'readonly');
    const store = tx.objectStore('lines');
    const req = store.openCursor();
    let seen=0, choice=null, choiceCount=0;
    req.onsuccess = ()=>{
      const cur = req.result;
      if(!cur || seen>=maxScan){ return resolve(choice); }
      const val = cur.value;
      if(!val.owned && !OFFERING.has(val.id)){
        choiceCount++;
        if(Math.random()<1/choiceCount) choice=val;
      }
      seen++;
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

/* ===================== OVERPASS + TILING ===================== */
// CZ + SK oblast, zhruba v kilometrech
const CE = { south: 47.0, north: 53.0, west: 11.5, east: 24.0 };
const TILES = generateTiles(CE, 30); // men≈°√≠ dla≈ædice: 30 km m√≠sto 50 km
    function generateTiles(region=CE, km=30)
    {
  const tiles=[];
  const dLat=km/111;
  for(let lat=region.south; lat<region.north; lat+=dLat){
    const phi = lat*Math.PI/180;
    const dLon=km/(111*Math.cos(phi));
    for(let lon=region.west; lon<region.east; lon+=dLon){
      const s=lat, n=Math.min(lat+dLat,region.north), w=lon, e=Math.min(lon+dLon,region.east);
      tiles.push({s,w,n,e});
    }
  }
  return tiles;
}
let tilesDone = new Set(); // runtime
updateTilesBadge();

function bboxKey(t){ return `${t.s.toFixed(3)},${t.w.toFixed(3)},${t.n.toFixed(3)},${t.e.toFixed(3)}`; }
function updateTilesBadge(){ tilesCountEl.textContent = `${tilesDone.size}/${TILES.length} dla≈ædic`; }

async function overpassJSON(query){
  const res = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', body:query });
  if(!res.ok) throw new Error(`Overpass ${res.status}`);
  return res.json();
}

function extractStopsOrdered(rel, nodesById){
  const isStopRole = r => r==='stop'||r==='stop_entry_only'||r==='stop_exit_only';
  const isPlatRole = r => r==='platform'||r==='platform_entry_only'||r==='platform_exit_only';
  const mem = rel.members||[];
  let stops = mem.filter(m=>m.type==='node'&&isStopRole(m.role)).map(m=>nodesById[m.ref]).filter(Boolean);
  if(stops.length<2){
    stops = mem.filter(m=>m.type==='node'&&isPlatRole(m.role)).map(m=>nodesById[m.ref]).filter(Boolean);
  }
  return stops.length>=2 ? stops.map(s=>[s.lat,s.lon]) : [];
}

function distanceKm(a,b){ return L.latLng(a).distanceTo(L.latLng(b))/1000; }
function polylineKm(coords){ let d=0; for(let i=1;i<coords.length;i++) d+=distanceKm(coords[i-1],coords[i]); return d; }

function normalizeType(tags){
  const t = (tags && tags.route) ? String(tags.route) : '';
  if(/bus/i.test(t)) return 'bus';
  if(/tram/i.test(t)) return 'tram';
  if(/train|rail/i.test(t)) return 'train';
  if(/air|flight/i.test(t)) return 'plane';
  return 'bus';
}

/* ===================== PERSISTENT TILES ===================== */
async function loadTilesDone(){
  const tx = db.transaction('meta','readonly');
  const store = tx.objectStore('meta');
  return new Promise(resolve=>{
    const req = store.get('tilesDone');
    req.onsuccess = ()=>{ if(req.result && Array.isArray(req.result.value)) tilesDone=new Set(req.result.value); resolve(); };
    req.onerror = ()=>resolve();
  });
}

async function saveTilesDone(){
  const tx = db.transaction('meta','readwrite');
  const store = tx.objectStore('meta');
  store.put({key:'tilesDone', value:[...tilesDone]});
}

/* ===================== FETCH TILE ===================== */
async function fetchTileToDB(tile){
  const key=bboxKey(tile);
  if(tilesDone.has(key)) return;
  setStatus(`Stahuji dla≈ædici ${key}‚Ä¶`);
  const q=`[out:json][timeout:90];(relation["route"~"^(bus|tram|train|air|flight)$"](${tile.s},${tile.w},${tile.n},${tile.e});); out body; >; out skel qt;`;
  try{
    const json = await overpassJSON(q);
    const nodesById = {};
    (json.elements||[]).forEach(el=>{ if(el.type==='node') nodesById[el.id]=el; });
    const rels = (json.elements||[]).filter(el=>el.type==='relation');
    const toStore=[];
    for(const rel of rels){
      const coords = extractStopsOrdered(rel,nodesById);
      if(coords.length<2) continue;
      const km = polylineKm(coords);
      if(!isFinite(km)||km<=0) continue;
      const type = normalizeType(rel.tags||{});
      const name = rel.tags && rel.tags.name ? rel.tags.name : `Linka ${rel.id}`;
      const price = Math.max(1, Math.round(km*10));
      toStore.push({id:rel.id,type,name,coords,km,price,bboxKey:key,owned:false,tags:rel.tags||{}});
    }
    if(toStore.length) await putLines(toStore);
    tilesDone.add(key);
    saveTilesDone();
    updateTilesBadge();
  }catch(e){ console.warn('Tile fetch failed',e); }
}

/* sekvenƒçn√≠ stahov√°n√≠ dla≈ædic */
/* sekvenƒçn√≠ stahov√°n√≠ dla≈ædic (≈°et≈ôen√©) */
async function sequentialPrefetch(delayMs=5000, firstBurst=3){
  // rychl√Ω √∫vod ‚Äì prvn√≠ dla≈ædice, kter√© je≈°tƒõ nejsou sta≈æen√©
  for(let i=0, added=0; i<TILES.length && added<firstBurst; i++){
    const t = TILES[i];
    if(!tilesDone.has(bboxKey(t))){
      if(!navigator.onLine) break;
      await fetchTileToDB(t);
      await saveTilesDone();
      added++;
    }
  }

  // pak klidnƒõ dokola
  let idx = 0;
  const loop = async ()=>{
    if(!navigator.onLine){ 
      setStatus('offline ‚Äì naƒç√≠t√°n√≠ pozastaveno'); 
      return; 
    }

    let found = false;
    const total = TILES.length;
    for(let attempts=0; attempts<total; attempts++){
      const t = TILES[idx++ % total];
      if(!tilesDone.has(bboxKey(t))){
        await fetchTileToDB(t);
        await saveTilesDone();
        found = true;
        break;
      }
    }

    if(!found){
      setStatus('v≈°echny dla≈ædice ji≈æ sta≈æeny ‚Äì hra pokraƒçuje');
    } else {
      setTimeout(loop, delayMs);
    }
  };

  setTimeout(loop, delayMs);
}

/* ===================== SPAWN + VEHICLES ===================== */
function iconForType(t){
  if(t==='tram') return TRAM_ICON;
  if(t==='train') return TRAIN_ICON;
  if(t==='plane') return PLANE_ICON;
  return BUS_ICON;
}

/* plynul√© pendlov√°n√≠ + v√Ωdƒõlek za projet√Ω km (12 Kƒç/km) */
function runVehiclePendulum(marker, coords, speedKmh=70, ratePerKm=12){
  const speed = (speedKmh*1000)/3600;
  const seg = [];
  for(let i=0;i<coords.length-1;i++){
    const a=L.latLng(coords[i]), b=L.latLng(coords[i+1]);
    const d=a.distanceTo(b);
    if(d>0) seg.push({a,b,d});
  }
  if(seg.length===0) return;
  let idx=0, dist=0, dir=1;
  const tick=50; const step=speed*(tick/1000);

  setInterval(()=>{
    dist+=step;
    while(dist>seg[idx].d && seg[idx].d>0){
      const earn = (seg[idx].d/1000) * ratePerKm;
      setMoney(Math.round(money + earn));
      dist-=seg[idx].d;
      idx+=dir;
      if(idx>=seg.length){ dir=-1; idx=seg.length-1; dist=0; }
      if(idx<0){ dir=1; idx=0; dist=0; }
    }
    const s = seg[idx].d===0?0:dist/seg[idx].d;
    const lat = seg[idx].a.lat + (seg[idx].b.lat - seg[idx].a.lat)*s;
    const lng = seg[idx].a.lng + (seg[idx].b.lng - seg[idx].a.lng)*s;
    marker.setLatLng([lat,lng]);
  }, tick);
}

function spawnVehicle(line){
  const marker = L.marker(line.coords[0], { icon: iconForType(line.type) }).addTo(map);
  let poly = null;

  // popup se vytvo≈ô√≠ hned p≈ôi inicializaci markeru
  const popupHtml = `
    üöç <b>${line.name}</b><br>
    <small>${line.type.toUpperCase()} ‚Ä¢ ID ${line.id}</small><br>
    <small>D√©lka: ${line.km.toFixed(1)} km</small><br>
    <small>Cena: ${line.price} Kƒç</small>
  `;
  marker.bindPopup(popupHtml);

  // kliknut√≠ ‚Äì otev≈ôe popup a vykresl√≠ trasu
  marker.on('click', () => {
    if (poly) {
      map.removeLayer(poly);
      poly = null;
    }
    poly = L.polyline(line.coords, { color: 'blue' }).addTo(map);
    marker.openPopup();
  });

  // po zav≈ôen√≠ popupu odstran√≠me trasu
  marker.on('popupclose', () => {
    if (poly) {
      map.removeLayer(poly);
      poly = null;
    }
  });

  // spust√≠me pohyb vozidla
  runVehiclePendulum(marker, line.coords, 70, 12);
}


/* ===================== NAB√çDKA LINEK ===================== */
async function offerOneFromDB(){
  const line = await getRandomOfferableLine();
  if(!line){ updateBadges(); return; }
  OFFERING.add(line.id);
  updateBadges();

  const card = document.createElement('div');
  card.className='offer'; card.id=`offer-${line.id}`;
  card.innerHTML=`
    <b>${line.name}</b> <span class="pill">${line.type}</span><br/>
    <span class="muted">ID ${line.id}</span><br/>
    <span class="muted">D√©lka: ${line.km.toFixed(1)} km</span><br/>
    <span class="muted">Cena: ${line.price} Kƒç</span><br/>
    <button class="btn">Koupit</button>
  `;
  const btn = card.querySelector('button');
  btn.onclick = async ()=>{
    if(money < line.price){ alert('Nem√°≈° dost penƒõz!'); return; }
    setMoney(money - line.price);
    await markOwned(line.id);
    OFFERING.delete(line.id);
    ownedCount++; updateBadges();
    card.remove();
    spawnVehicle(line);
  };
  offersEl.appendChild(card);
}

setInterval(offerOneFromDB, 3000);

/* ===================== BOOTSTRAP ===================== */
(async function(){
  db = await openDB();
  setStatus('DB p≈ôipravena. Naƒç√≠t√°m info o sta≈æen√Ωch dla≈ædic√≠ch‚Ä¶');
  await loadTilesDone();
  updateTilesBadge();
  updateBadges();

  if(navigator.onLine){
    sequentialPrefetch(7000,3);
  } else {
    setStatus('offline ‚Äì pou≈æ√≠v√°m pouze IndexedDB');
  }
})();


/* ===================== RESET / NOV√Å HRA ===================== */
const resetBtn = document.createElement('button');
resetBtn.textContent = 'üîÅ Nov√° hra';
resetBtn.className = 'btn';
resetBtn.style.marginTop = '10px';
document.getElementById('menu').appendChild(resetBtn);

resetBtn.onclick = async () => {
  if (!confirm('Opravdu chce≈° zaƒç√≠t novou hru? V≈°echny koupen√© linky budou zapomenuty.')) return;

  // zav≈ôeme nab√≠dku a resetujeme stav
  document.getElementById('menu').classList.remove('open');
  setStatus('üßπ Ma≈æu star√° data...');

  const tx = db.transaction(['lines','owned'], 'readwrite');
  tx.objectStore('lines').clear();
  tx.objectStore('owned').clear();

  await new Promise(res => tx.oncomplete = res);
  ownedInSession.clear();
  OFFERING.clear();
  offersEl.innerHTML = '';
  updateBadges();

  setMoney(2000);
  setStatus('‚úÖ Nov√° hra p≈ôipravena ‚Äì znovu se naƒç√≠taj√≠ linky...');
  tilesDone.clear();
  await saveTilesDone();
  sequentialPrefetch(7000, 3);
};
</script>
</body>
</html>